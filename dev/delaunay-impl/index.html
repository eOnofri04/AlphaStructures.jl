<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4.1 - DeWall Algorithm · AlphaStructures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="AlphaStructures.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">AlphaStructures.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">1 - Home</a></li><li><a class="tocitem" href="../gettingStarted/">2 - Getting Started</a></li><li><span class="tocitem">Theory...</span><ul><li><a class="tocitem" href="../theory-index/">3.0 - Theory Index</a></li><li><a class="tocitem" href="../delaunay/">3.1 - Delaunay Triangulation</a></li><li><a class="tocitem" href="../voronoi/">3.2 - Voronoi Diagrams</a></li><li><a class="tocitem" href="../alpha-structures/">3.3 - Alpha Structures</a></li><li><a class="tocitem" href="../persistent-homology/">3.4 - Persistent Homology</a></li></ul></li><li><span class="tocitem">... and Practice</span><ul><li><a class="tocitem" href="../this-module/">4.0 - Module Introduction</a></li><li class="is-active"><a class="tocitem" href>4.1 - DeWall Algorithm</a><ul class="internal"><li><a class="tocitem" href="#Advantage"><span>Advantage</span></a></li><li><a class="tocitem" href="#Delauany-Wall-Pipeline"><span>Delauany Wall Pipeline</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Main-Interface"><span>Main Interface</span></a></li></ul></li><li><a class="tocitem" href="../alpha-structures-impl/">4.2 - Alpha Structures</a></li><li><a class="tocitem" href="../persistent-homology-impl/">4.3 - Persistent Homology</a></li></ul></li><li><a class="tocitem" href="../authors/">A - About the Authors</a></li><li><a class="tocitem" href="../bibliography/">B - Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">... and Practice</a></li><li class="is-active"><a href>4.1 - DeWall Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4.1 - DeWall Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/eOnofri04/AlphaStructures.jl/blob/master/docs/src/delaunay-impl.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".1-Delaunay-Wall-Triangulation-Algorithm"><a class="docs-heading-anchor" href="#.1-Delaunay-Wall-Triangulation-Algorithm">4.1 - Delaunay Wall Triangulation Algorithm</a><a id=".1-Delaunay-Wall-Triangulation-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#.1-Delaunay-Wall-Triangulation-Algorithm" title="Permalink"></a></h1><p>We approached the problem as described in [CMS97] and [CMS98].</p><h2 id="Advantage"><a class="docs-heading-anchor" href="#Advantage">Advantage</a><a id="Advantage-1"></a><a class="docs-heading-anchor-permalink" href="#Advantage" title="Permalink"></a></h2><p>The duality between Delaunay Triangulations and Voronoi diagrams has been discussed in <a href="https://eonofri04.github.io/AlphaStructures.jl/delaunay/">section 3.1</a> and <a href="https://eonofri04.github.io/AlphaStructures.jl/voronoy/">section 3.2</a>. However, direct construction methods are generally more efficient because the Voronoi diagram does not need to be computed and stored. Various approaches have been historically used:</p><ul><li>Local improvement: starting with an arbitrary triangulation these algorithms locally modify the faces of pairs of adjacent simplices according to the circumsphere criterion.</li><li>On line (or incremental insertion): starting with a simplex which contains the convex hull of the point set these algorithms insert the points in <code>P</code> one at a time. The simplex containing the currently added point is partitioned by inserting it as a new vertex. The circumsphere criterion is tested on all the simplices adjacent to the new ones recursively and, if necessary, their faces are flipped.</li><li>Incremental construction: the DT is constructed by successively building simplices whose circumhyperspheres contain no points in <code>P</code>.</li><li>Higher dimensional embedding: these algorithms transform the points into the <span>$E^{d+1}$</span> space and then compute the convex hull of the transformed points the DT is obtained by simply projecting the convex hull into <span>$E^{d}$</span>.</li><li>Classic D&amp;C algorithms: this is based on the recursive partition and local triangulation of the point set and then on a merging phase where the resulting triangulations are joined.</li></ul><p>The algorithm we have choosen to encode is one of the latter class. Its peculiarity is that the computational phase is located in the Divide Step (instead of the merge step). Delaunay Wall algorithm first subdivides the input dataset, then builds that part of the DT that should be built in the merge phase of a classic D&amp;C algorithm and then recursively triangulates the two half–spaces, taking into account the border of the previously computed merge triangulation.</p><h2 id="Delauany-Wall-Pipeline"><a class="docs-heading-anchor" href="#Delauany-Wall-Pipeline">Delauany Wall Pipeline</a><a id="Delauany-Wall-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Delauany-Wall-Pipeline" title="Permalink"></a></h2><p>The DeWall (Delaunay Wall) algorithm could be summed up by following pipeline:</p><ol><li>select a hyperplane <span>$\alpha$</span> that divides the space into two halfspaces</li><li>split the sites <span>$S$</span> into two subset: <span>$S^-$</span> and <span>$S^+$</span> (the points in the negative and positive halfspace)</li><li>construct the <em>Wall</em> (<span>$\Sigma^\alpha$</span>) of the Delaunay simplices over that intersect the plane <span>$\alpha$</span></li><li>recursively apply DeWall on <span>$S^-$</span> to obtain <span>$\Sigma^-$</span></li><li>recursively apply DeWall on <span>$S^+$</span> ro obtain <span>$\Sigma^+$</span></li><li>merge <span>$\Sigma^\alpha$</span>, <span>$\Sigma^-$</span> and <span>$\Sigma^+$</span>.</li></ol><p>In particular we have that:</p><p class="math-container">\[	\Sigma^\alpha = \{\sigma \in \mathcal D_S \mid \sigma \cap \alpha \ne \emptyset \}\]</p><p class="math-container">\[	\Sigma^- = \{\sigma \in \mathcal D_S \mid \sigma \in \mbox{NegHalfspace}(\alpha)\}\]</p><p class="math-container">\[	\Sigma^+ = \{\sigma \in \mathcal D_S \mid \sigma \in \mbox{PosHalfspace}(\alpha)\}\]</p><p>and therefore by construction we have that <span>$\Sigma^\alpha$</span>, <span>$\Sigma^-$</span> and <span>$\Sigma^+$</span> are disjoint and</p><p class="math-container">\[	\Sigma^\alpha \cup \Sigma^- \cup \Sigma^+ = \mathcal D_S\]</p><h3 id="Construct-simplex-wall-S\\alpha"><a class="docs-heading-anchor" href="#Construct-simplex-wall-S\\alpha">Construct simplex wall <span>$S^\alpha$</span></a><a id="Construct-simplex-wall-S\\alpha-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-simplex-wall-S\\alpha" title="Permalink"></a></h3><p>The simplex wall <span>$\Sigma^\alpha$</span> can be simply computed by using an incremental construction approach.</p><p>First of all we define three <strong>active face lists</strong>:</p><ul><li><span>$AFL^\alpha$</span>: the <span>$(d - 1)$</span>-simplices intersecting <span>$\alpha$</span></li><li><span>$AFL^+$</span>: the <span>$(d - 1)$</span>-simplices totally located in the negative halfspace defined by <span>$\alpha$</span></li><li><span>$AFL^-$</span>: the <span>$(d - 1)$</span>-simplices totally located in the positive halfspace defined by <span>$\alpha$</span></li></ul><p>The algorithm starts by constructing an initial <span>$d$</span>-simplex <span>$\sigma_0$</span> that intersect the hyperplane (if no active faces are provided). Then, it processes all of the <span>$(d - 1)$</span>-simplices of <span>$σ_0$</span> by splitting them into the Active Face Lists. From now on the <span>$AFL^\alpha$</span> is progressively emptied (and filled) by taking one at time the simplices in it.</p><p>For each <span>$d-1$</span>-simplex <span>$\eta$</span> (wich will belongs to a <span>$d$</span>-simplex <span>$\sigma^1 \in \mathcal D_S$</span>) the algorithm finds out the only other <span>$d$</span>-simplex <span>$\sigma^2$</span> (if it exists) incident on <span>$\eta$</span>: to do so the algorithm looks for the closest point (according to circumradius distance) to the face that do not belongs to the halfspace where the simplex <span>$\sigma^1$</span> is. Lastly all of the new <span>$(d - 1)$</span>-simplex of <span>$\sigma^2$</span> are splitted between the Active Face Lists (do not that in this procedure, if a face is already present in the AFL than it is simply removed since the two simplices incident over it have been found).</p><div class="admonition is-category-fact"><header class="admonition-header">Fact</header><div class="admonition-body"><p>For each <span>$(d - 1)$</span>-simplex <span>$\eta$</span>, which does not lie on the convex hull of <span>$S$</span>, there are exactly two simplices <span>$\sigma^1$</span> and <span>$\sigma^2$</span> in <span>$\mathcal D_S$</span>, such that <span>$\sigma^1 \cap \sigma^2 = f$</span>. If the algorithm is not able to find out a second simplex incident on <span>$\eta$</span> we can therefore claim that that simplex belongs to the convex hull of <span>$S$</span>.</p></div></div><p>When the process is over, the wall has been built. It remains to use the Active Face Lists of the positive and negative halfspaces.</p><h3 id="Recursively-call-DeWall"><a class="docs-heading-anchor" href="#Recursively-call-DeWall">Recursively call DeWall</a><a id="Recursively-call-DeWall-1"></a><a class="docs-heading-anchor-permalink" href="#Recursively-call-DeWall" title="Permalink"></a></h3><p>The wall building process is then applied again to the two halfspaces defined by <span>$\alpha$</span> by choosing another <span>$\alpha$</span>-hyperplane. However if only the points in the halfspace are given to the new call of the function, a careful look must be given to the new simplex evaluated. In fact it could happen that point that earlier where closer to points in the other halfspace, now are closer to other points in the same halfspace. To avoid this annoying situation (solvable in the merge phase checking if any simplex is intersecting any other) a faster solution is to bring into the recursive step also the points that forms the previous walls and discard the simplices that will be formed with that points (in our code, the <code>blacklist</code>).</p><h3 id="Merging-the-Delaunay-Triangulations"><a class="docs-heading-anchor" href="#Merging-the-Delaunay-Triangulations">Merging the Delaunay Triangulations</a><a id="Merging-the-Delaunay-Triangulations-1"></a><a class="docs-heading-anchor-permalink" href="#Merging-the-Delaunay-Triangulations" title="Permalink"></a></h3><p>If the trick described in the last paragraph have been applied than no particular operations but the merging must be made at this point. In fact the triangulations will be completely disjoint and their intersection will give us back only <span>$AFL^-$</span> and <span>$AFL^+$</span>.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>The input is a set of points in <span>$\mathcal R^d$</span>, of type <code>Matrix</code>, the output is a set of <span>$d$</span>-simplices, of type <code>Array{Array{Int64,1},1}</code>. So we can create a LAR model to view.</p><h3 id="D-Delaunay-triangulation"><a class="docs-heading-anchor" href="#D-Delaunay-triangulation">3D Delaunay triangulation</a><a id="D-Delaunay-triangulation-1"></a><a class="docs-heading-anchor-permalink" href="#D-Delaunay-triangulation" title="Permalink"></a></h3><pre><code class="language-julia">julia&gt; using AlphaStructures, ViewerGL;

julia&gt; GL = ViewerGL;

julia&gt; V = [
 0.0 1.0 0.0 1.0 0.0 1.0 0.0 1.0
 0.0 0.0 1.0 1.0 0.0 0.0 1.0 1.0
 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0
];

julia&gt; DT = AlphaStructures.delaunayWall(V)
6-element Array{Array{Int64,1},1}:
 [1, 2, 4, 5]
 [1, 3, 4, 5]
 [2, 4, 5, 6]
 [3, 4, 5, 7]
 [4, 5, 6, 7]
 [4, 6, 7, 8]

julia&gt; GL.VIEW([
	GL.GLExplode(
		VS,
		[[σ] for σ in DT],
		1.5, 1.5, 1.5,	# Explode Ratio
		99, 1			# Colors
	)
]);
</code></pre><p><img src="../images/3Ddelaunay.png" alt="3Ddelaunay"/></p><h3 id="D-Delaunay-triangulation-2"><a class="docs-heading-anchor" href="#D-Delaunay-triangulation-2">2D Delaunay triangulation</a><a class="docs-heading-anchor-permalink" href="#D-Delaunay-triangulation-2" title="Permalink"></a></h3><pre><code class="language-julia">
julia&gt; using AlphaStructures, ViewerGL;

julia&gt; GL = ViewerGL;

julia&gt; V = [
 0.0 2.0 0.0 4.0 5.0
 0.0 0.0 3.0 1.0 5.0
];

julia&gt; DT = AlphaStructures.delaunayWall(V)
3-element Array{Array{Int64,1},1}:
 [2, 3, 4]
 [3, 4, 5]
 [1, 2, 3]

julia&gt; GL.VIEW([
	GL.GLExplode(
		VS,
		[[σ] for σ in DT],
		1., 1.,	1.	# Explode Ratio
		99, 1		# Colors
	)
]);
</code></pre><p><img src="../images/2Ddelaunay.png" alt="2Ddelaunay"/></p><h2 id="Main-Interface"><a class="docs-heading-anchor" href="#Main-Interface">Main Interface</a><a id="Main-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Interface" title="Permalink"></a></h2><p>The solution we have proposed is located in the <code>alphaFilter</code> function (in <a href="https://github.com/eOnofri04/AlphaStructures.jl/blob/master/src/deWall.jl">this</a> file):</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphaStructures.delaunayWall</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphaStructures.findWallSimplex</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphaStructures.firstDeWallSimplex</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AlphaStructures.recursiveDelaunayWall</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../this-module/">« 4.0 - Module Introduction</a><a class="docs-footer-nextpage" href="../alpha-structures-impl/">4.2 - Alpha Structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 11:03">Tuesday 13 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
